package com.company;

import data.Grid;

import java.util.ArrayList;
import java.util.List;

public class PuzzleBlock implements BlockSortable {
	int countPermutations = 0;
	List<Integer> permutation1 = new ArrayList<>();
	List<Integer> permutation2 = new ArrayList<>();
	List<Integer> permutation3 = new ArrayList<>();
	List<Integer> permutation4 = new ArrayList<>();
	List<Integer> permutation5 = new ArrayList<>();
	List<Integer> permutation6 = new ArrayList<>();

	int[] usedNumbers1 = { 0, 0, 0, 0, 0, 0, 0, 0, 0 };
	int[] usedNumbers2 = { 0, 0, 0, 0, 0, 0, 0, 0, 0 };
	int[] usedNumbers3 = { 0, 0, 0, 0, 0, 0, 0, 0, 0 };
	int[] usedNumbers4 = { 0, 0, 0, 0, 0, 0, 0, 0, 0 };
	int[] usedNumbers5 = { 0, 0, 0, 0, 0, 0, 0, 0, 0 };
	int[] usedNumbers6 = { 0, 0, 0, 0, 0, 0, 0, 0, 0 };

	int rowCounter = 1; 
	int extensionCount = 0;
	boolean extensionTookPlace = false;

	/**
	 * This method interprets a number between 0-8 as coordinates of one of the 9
	 * anchor cells. E.g. 3 (fourth number) represents the anchor cell with
	 * coordinates 4,1 so a two-dimensional array consisting {4,1} is returned.
	 * 
	 * @author Alexander Nikolov
	 * @param i A digit from 0-8 representing a block in a 9x9 grid.
	 * @return Returns a two-dimensional array which translates 0 into 1,1; 1 into
	 *         1,4 and so on.
	 */
	public int[] intToAnchor(int i) {
		int[] result = new int[2];
		switch (i) {
		case 0:
			result[0] = 1;
			result[1] = 1;
			break;
		case 1:
			result[0] = 1;
			result[1] = 4;
			break;
		case 2:
			result[0] = 1;
			result[1] = 7;
			break;
		case 3:
			result[0] = 4;
			result[1] = 1;
			break;
		case 4:
			result[0] = 4;
			result[1] = 4;
			break;
		case 5:
			result[0] = 4;
			result[1] = 7;
			break;
		case 6:
			result[0] = 7;
			result[1] = 1;
			break;
		case 7:
			result[0] = 7;
			result[1] = 4;
			break;
		case 8:
			result[0] = 7;
			result[1] = 7;
			break;

		}

		return result;
	}

	/**
	 * Uses the last 9-digit permutation generated by the methods 1-6
	 * (isBlockConflictFree etc.) and constructs the grid based on the order of the
	 * digits (which are being translated into anchor cells by the method
	 * "intToAnchor").
	 * 
	 * @author Alexander Nikolov
	 * @param grid The grid.
	 * @param test This list contains a permutation with the digits between 1-9
	 */
	public Grid constructGrid(Grid grid, List<Integer> test) {

		// add all the blocks by using a new method which uses the anchor cells
		Grid result = new Grid(9);
		for (int k = 0; k < 9; k++) {
			for (int r = 0; r < 3; r++) {
				for (int c = 0; c < 3; c++) {
					// sets the value of the cells depending on the order of the values in "test".
					// Uses the method "intToAnchor" to translate the numbers 1-9 to 2-dimensional
					// int arrays defining the anchor cells. so 1 e.g. is {1,1}, 4={4,1}
					result.setValue(r + intToAnchor(k)[0], c + intToAnchor(k)[1],
							grid.getValue(r + intToAnchor(test.get(k))[0], c + intToAnchor(test.get(k))[1]));
				}
			}
		}
		return result;
	}

	/**
	 * Compares the 3th with the 4th and the 6th with the 7th cell of every row in
	 * the grid. If any of them match, the grid is not h-conflict free. All the
	 * other neighboring cells (e.g. 1st and 2nd column) are not checked because we
	 * assume that the blocks themselves are h-conflict free.
	 * 
	 * @author Alexander Nikolov
	 * @param grid The grid we are working on.
	 * @return Returns true if the given grid is h-conflict free.
	 */
	public boolean isBlockConflictFree(Grid grid) {
		boolean result = true;
		for (int row = 1; row < 10; row++) {
			if (grid.getValue(row, 3) == grid.getValue(row, 4) || grid.getValue(row, 6) == grid.getValue(row, 7)) {
				return false;
			}
		}
		return result;
	}

	/**
	 * This method recursively creates all possible permutations of the numbers
	 * between 0-8. It always memorizes which of the numbers 0-8 have been used so
	 * far (as they may appear only once) in the variable "usedNumbers1" and selects
	 * the first available number and adds it to the List "permutation1".
	 *
	 * After finishing one recursion, it checks if the length of the list is 9. In
	 * case it is, it calls the method constructGrid which uses the 9 values (which
	 * stand for the 9 anchor cells) to construct a full grid. Then it checks
	 * whether the resulting grid is h-conflict free by calling the method
	 * isBlockConflictFree and returns the grid in case it is conflict-free. If is
	 * not conflict-free it returns the number p back to the available numbers and
	 * takes the next available number from the list to make up a different
	 * permutation in "permutation1". So the development of the permutations is as
	 * follows: 012345678, 012345687, 012345768, 012345786, 012345867, 012345876
	 * etc.
	 *
	 * In case after going through all possible permutations still no conflict-free
	 * grid has been found, a null-grid is returned.
	 * 
	 * @author Alexander Nikolov
	 * @param grid The grid to check.
	 * @return Returns a conflict-free grid if possible, otherwise a null-grid.
	 */
	public Grid getBlockConflictFree(Grid grid) {
		if (permutation1.size() != 9) {
			for (int p = 0; p < 9; p++) {
				if (usedNumbers1[p] == 0) {
					permutation1.add(p);
					usedNumbers1[p] = 1;
					getBlockConflictFree(grid);
					if (permutation1.size() == 9) {
						Grid testGrid = constructGrid(grid, permutation1);
						if (isBlockConflictFree(testGrid)) {
							for (int k = 0; k < 9; k++) {
								usedNumbers1[k] = 0;
							}
							return testGrid;
						}
					}
					usedNumbers1[p] = 0;
					permutation1.remove(permutation1.size() - 1);
				}
			}
		}
		return nullGrid();
	}

	/**
	 * Constructs a Grid filled with zeros.
	 * 
	 * @author Alexander Nikolov
	 * @return Returns a 9x9 grid filled with zeros.
	 */
	public Grid nullGrid() {
		Grid nullGrid = new Grid(9);
		nullGrid.setRowValues(1, new int[] { 0, 0, 0, 0, 0, 0, 0, 0, 0 });
		nullGrid.setRowValues(2, new int[] { 0, 0, 0, 0, 0, 0, 0, 0, 0 });
		nullGrid.setRowValues(3, new int[] { 0, 0, 0, 0, 0, 0, 0, 0, 0 });
		nullGrid.setRowValues(4, new int[] { 0, 0, 0, 0, 0, 0, 0, 0, 0 });
		nullGrid.setRowValues(5, new int[] { 0, 0, 0, 0, 0, 0, 0, 0, 0 });
		nullGrid.setRowValues(6, new int[] { 0, 0, 0, 0, 0, 0, 0, 0, 0 });
		nullGrid.setRowValues(7, new int[] { 0, 0, 0, 0, 0, 0, 0, 0, 0 });
		nullGrid.setRowValues(8, new int[] { 0, 0, 0, 0, 0, 0, 0, 0, 0 });
		nullGrid.setRowValues(9, new int[] { 0, 0, 0, 0, 0, 0, 0, 0, 0 });
		return nullGrid;
	}

	/**
	 * This method recursively creates all possible permutations of the numbers
	 * between 0-8. It always memorizes which of the numbers 0-8 have been used so
	 * far (as they may appear only once) in the variable "usedNumbers2" and selects
	 * the first available number and adds it to the List "permutation2".
	 *
	 * After finishing one recursion, it checks if the length of the list is 9. In
	 * case it is, it calls the method constructGrid which uses the 9 values (which
	 * stand for the 9 anchor cells) to construct a full grid. Then it checks
	 * whether the resulting grid is h-conflict free by calling the method
	 * isBlockConflictFree and returns true in case it is conflict-free. If is not
	 * conflict-free it returns the number p back to the available numbers and takes
	 * the next available number from the list to make up a different permutation in
	 * "permutation2". So the development of the permutations is as follows:
	 * 012345678, 012345687, 012345768, 012345786, 012345867, 012345876 etc.
	 *
	 * In case after going through all possible permutations still no conflict-free
	 * grid has been found, false is returned.
	 * 
	 * @author Alexander Nikolov
	 * @param grid The grid to check.
	 * @return Returns true if there is a conflict-free permutation of the grid,
	 *         otherwise false.
	 */
	@Override
	public boolean hasBlockConflictFree(Grid grid) {
		if (permutation2.size() != 9) {
			for (int p = 0; p < 9; p++) {
				if (usedNumbers2[p] == 0) {
					permutation2.add(p);
					usedNumbers2[p] = 1;
					hasBlockConflictFree(grid);
					if (permutation2.size() == 9) {
						Grid testGrid = constructGrid(grid, permutation2);
						if (isBlockConflictFree(testGrid)) {
							for (int k = 0; k < 9; k++) {
								usedNumbers2[k] = 0;
							}
							return true;
						}
					}
					usedNumbers2[p] = 0;
					permutation2.remove(permutation2.size() - 1);
				}
			}
		}
		return false;
	}

	/**
	 *
	 * This method recursively creates all possible permutations of the numbers
	 * between 0-8. It always memorizes which of the numbers 0-8 have been used so
	 * far (as they may appear only once) in the variable "usedNumbers3" and selects
	 * the first available number and adds it to the List "permutation3".
	 *
	 * After finishing one recursion, it checks if the length of the list is 9. In
	 * case it is, it calls the method constructGrid which uses the 9 values (which
	 * stand for the 9 anchor cells) to construct a full grid. Then it checks
	 * whether every number 1-9 appears in it only once for every column and row by
	 * calling the method "appearsOnceRowCol" and returns the grid in case it has
	 * this property. If does not, it returns the number p back to the available
	 * numbers and takes the next available number from the list to make up a
	 * different permutation in "permutation3". So the development of the
	 * permutations is as follows: 012345678, 012345687, 012345768, 012345786,
	 * 012345867, 012345876 etc.
	 *
	 * In case after going through all possible permutations still no grid with the
	 * property has been found, a null-grid is returned.
	 * 
	 * @author Alexander Nikolov
	 * @param grid The grid to work on.
	 * @return Returns "true" if there is a permutation of the grid so that every
	 *         number appears once in every column and row, otherwise false.
	 */

	@Override
	public Grid getBlockSortColRow(Grid grid) {

		if (permutation3.size() != 9) {
			for (int p = 0; p < 9; p++) {
				if (usedNumbers3[p] == 0) {
					permutation3.add(p);
					usedNumbers3[p] = 1;
					getBlockSortColRow(grid);
					if (permutation3.size() == 9) {
						Grid testGrid = constructGrid(grid, permutation3);
						if (appearsOnceRowCol(testGrid)) {
							for (int k = 0; k < 9; k++) {
								usedNumbers3[k] = 0;
							}
							return testGrid;
						}
					}
					usedNumbers3[p] = 0;
					permutation3.remove(permutation3.size() - 1);
				}
			}
		}
		return nullGrid();
	}

	/**
	 * This method receives a grid constructed from a permutation in the method
	 * hasBlockSortColRow and checks whether every number 1-9 appears only once in
	 * every column and row. First it tracks the number of times a number has
	 * appeared in a given row with the variable "counter". Then it does the same
	 * for a given column. If in any of the numbers 1-9 appear more than once for a
	 * given column or row, return false.
	 * 
	 * @author Alexander Nikolov
	 * @param grid The grid to check.
	 * @return returns true if a number appears only once in every row and every
	 *         column.
	 *
	 */
	public boolean appearsOnceRowCol(Grid grid) {
		boolean result = true;
		for (int row = 1; row < 10; row++) {
			int[] counter = { 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			for (int col = 1; col < 10; col++) {
				if (grid.getValue(row, col) != -1) {
					if (counter[grid.getValue(row, col) - 1] > 0) {
						return false;
					}
					counter[grid.getValue(row, col) - 1]++;
				} else {
					return false;
				}
			}
		}
		for (int col = 1; col < 10; col++) {
			int[] counter = { 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			for (int row = 1; row < 10; row++) {
				if (grid.getValue(row, col) != -1) {
					if (counter[grid.getValue(row, col) - 1] > 1) {
						return false;
					}
					counter[grid.getValue(row, col) - 1]++;
				} else {
					return false;
				}
			}
		}
		return result;
	}

	/**
	 * This method recursively creates all possible permutations of the numbers
	 * between 0-8. It always memorizes which of the numbers 0-8 have been used so
	 * far (as they may appear only once) in the variable "usedNumbers4" and selects
	 * the first available number and adds it to the List "permutation4".
	 *
	 * After finishing one recursion, it checks if the length of the list is 9. In
	 * case it is, it calls the method constructGrid which uses the 9 values (which
	 * stand for the 9 anchor cells) to construct a full grid. Then it checks
	 * whether every number 1-9 appears in it only once for every column and row by
	 * calling the method "appearsOnceRowCol" and returns the grid in case it has
	 * this property. If does not, it returns the number p back to the available
	 * numbers and takes the next available number from the list to make up a
	 * different permutation in "permutation4". So the development of the
	 * permutations is as follows: 012345678, 012345687, 012345768, 012345786,
	 * 012345867, 012345876 etc.
	 *
	 * In case after going through all possible permutations still no grid with the
	 * property has been found, a null-grid is returned.
	 *
	 * @author Alexander Nikolov
	 * @param grid The grid to work on.
	 * @return Returns true if there is a grid permutation where every number
	 *         appears once for every column and row, otherwise false.
	 */
	@Override
	public boolean hasBlockSortColRow(Grid grid) {
		if (permutation4.size() != 9) {
			for (int p = 0; p < 9; p++) {
				if (usedNumbers4[p] == 0) {
					permutation4.add(p);
					usedNumbers4[p] = 1;
					hasBlockSortColRow(grid);
					if (permutation4.size() == 9) {
						Grid testGrid = constructGrid(grid, permutation4);
						if (appearsOnceRowCol(testGrid)) {
							return true;
						}
					}
					usedNumbers4[p] = 0;
					permutation4.remove(permutation4.size() - 1);
				}
			}
		}
		return false;
	}

	/**
	 * This method recursively creates all possible permutations of the numbers
	 * between 0-8. It always memorizes which of the numbers 0-8 have been used so
	 * far (as they may appear only once) in the variable "usedNumbers5" and selects
	 * the first available number and adds it to the List "permutation5".
	 *
	 * After finishing one recursion, it checks if the length of the list is 9. In
	 * case it is, it calls the method constructGrid which uses the 9 values (which
	 * stand for the 9 anchor cells) to construct a full grid. Then it checks
	 * whether the grid is a sudoku (i.e. every number appears only once for every
	 * unit) by calling the method "appearsOnceRowCol" and "appearsOnceBlock" and
	 * returns the grid in case it is a sudoku. If it is not, it returns the number
	 * p back to the available numbers and takes the next available number from the
	 * list to make up a different permutation in "permutation5". So the development
	 * of the permutations is as follows: 012345678, 012345687, 012345768,
	 * 012345786, 012345867, 012345876 etc.
	 *
	 * In case after going through all possible permutations still no sudoku has
	 * been found, a null-grid is returned.
	 * 
	 * @author Alexander Nikolov
	 * @param grid The grid to check.
	 * @return In case it exists, a permutation of the grid which fulfills the
	 *         properties of a sudoku is returned, otherwise a null-grid.
	 */
	@Override
	public Grid getBlockSudoku(Grid grid) {
		if (permutation5.size() != 9) {
			for (int p = 0; p < 9; p++) {
				if (usedNumbers5[p] == 0) {
					permutation5.add(p);
					usedNumbers5[p] = 1;
					getBlockSudoku(grid);
					if (permutation5.size() == 9) {
						Grid testGrid = constructGrid(grid, permutation5);
						if (appearsOnceRowCol(testGrid) && appearsOnceBlock(testGrid)) {
							for (int k = 0; k < 9; k++) {
								usedNumbers5[k] = 0;
							}
							return testGrid;
						}
					}
					usedNumbers5[p] = 0;
					permutation5.remove(permutation5.size() - 1);
				}
			}
		}

		return nullGrid();
	}

	/**
	 * This method counts the amount of times a given number appears in every block
	 * of a grid by tracking them with the variable "counter". If any of the numbers
	 * in any of the blocks appear more than once, false is returned.
	 * 
	 * @author Alexander Nikolov
	 * @param grid The grid to work on.
	 * @return Returns true if every number appears only once for every block.
	 */
	public boolean appearsOnceBlock(Grid grid) {
		boolean result = true;
		for (int row = 1; row < 10; row += 3) {
			for (int col = 1; col < 10; col += 3) {
				int[] counter = { 0, 0, 0, 0, 0, 0, 0, 0, 0 }; // counts how often a given number has appeared
				for (int i = row; i < row + 3; i++) {
					for (int j = col; j < col + 3; j++) {
						if (grid.getValue(row, col) != -1) {
							if (counter[grid.getValue(i, j) - 1] > 1) {
								return false;
							}
							counter[grid.getValue(row, col) - 1]++;
						} else {
							return false;
						}
					}
				}
			}
		}

		return result;

	}

	/**
	 * This method recursively creates all possible permutations of the numbers
	 * between 0-8. It always memorizes which of the numbers 0-8 have been used so
	 * far (as they may appear only once) in the variable "usedNumbers6" and selects
	 * the first available number and adds it to the List "permutation6".
	 *
	 * After finishing one recursion, it checks if the length of the list is 9. In
	 * case it is, it calls the method constructGrid which uses the 9 values (which
	 * stand for the 9 anchor cells) to construct a full grid. Then it checks
	 * whether the grid is a sudoku (i.e. every number appears only once for every
	 * unit) by calling the method "appearsOnceRowCol" and "appearsOnceBlock" and
	 * returns "true" in case it is a sudoku. If it is not, it returns the number p
	 * back to the available numbers and takes the next available number from the
	 * list to make up a different permutation in "permutation6". So the development
	 * of the permutations is as follows: 012345678, 012345687, 012345768,
	 * 012345786, 012345867, 012345876 etc.
	 *
	 * In case after going through all possible permutations still no sudoku has
	 * been found, "false" is returned.
	 * 
	 * @author Alexander Nikolov
	 * @param grid The grid to work on.
	 * @return Returns true if there is a permutation of the grid which fulfills the
	 *         properties of a sudoku.
	 */
	@Override
	public boolean hasBlockSudoku(Grid grid) {
		if (permutation6.size() != 9) {
			for (int p = 0; p < 9; p++) {
				if (usedNumbers6[p] == 0) {
					permutation6.add(p);
					usedNumbers6[p] = 1;
					hasBlockSudoku(grid);
					if (permutation6.size() == 9) {
						Grid testGrid = constructGrid(grid, permutation6);
						if (appearsOnceRowCol(testGrid) && appearsOnceBlock(testGrid)) {
							for (int k = 0; k < 9; k++) {
								usedNumbers6[k] = 0;
							}
							return true;
						}
					}
					usedNumbers6[p] = 0;
					permutation6.remove(permutation6.size() - 1);
				}
			}
		}
		return false;
	}

	/**
	 * Clones a grid by going through every row and column.
	 * 
	 * @author Alexander Nikolov
	 * @param grid The grid to clone.
	 * @return Returns the clone.
	 */
	public Grid copyGrid(Grid grid) {
		Grid result = new Grid(9);
		for (int r = 1; r < 10; r++) {
			for (int c = 1; c < 10; c++) {
				result.setValue(r, c, grid.getValue(r, c));
			}
		}
		return result;
	}

	/**
	 * The method goes through the grid row-wise using the variable "rowCounter".
	 * "Number" must not already appear anywhere in the current row. If it does, go
	 * to the next row. Then, by going through every cell of the current row, search
	 * for the first available cell which is empty and for which the property
	 * applies that it must not appear in the column. If all these conditions are
	 * met, "number" is being put and we proceed to the next row and a recursive
	 * call is being made.
	 * 
	 * Once rowCounter reaches 10, it is time to increase "extensionCount" by one,
	 * but only in case any number has been put (which is being tracked by
	 * "extensionTookPlace), i.e. only in case any changes to the grid have been
	 * made. Because of its recursive nature, the method eventually goes through all
	 * possibilities in the same pattern as the first 6 methods do.
	 * 
	 * @author Alexander Nikolov
	 * @param grid   The grid to work on.
	 * @param number The number to use in the extension (Erweiterung).
	 */
	@Override
	public int putNumberColRow(Grid grid, int number) {
		Grid newGrid = copyGrid(grid);
		if (rowCounter < 10) {
			if (!appearsInTheRow(number, rowCounter, newGrid)) {
				for (int col = 1; col < 10; col++) {
					if (newGrid.getValue(rowCounter, col) == -1) {
						if (!appearsInTheColumn(number, col, newGrid)) {
							newGrid.setValue(rowCounter, col, number);
							extensionTookPlace = true;
							rowCounter++;
							putNumberColRow(newGrid, number);
							rowCounter--;
							newGrid.setValue(rowCounter, col, -1);
							extensionTookPlace = false;
						}
					}
				}
			} else {
				rowCounter++;
				putNumberColRow(newGrid, number);
				rowCounter--;
			}
		} 
		else if (extensionTookPlace) {
			extensionCount++;
			//extensionTookPlace = false;
		}
		return extensionCount;
	}

	/**
	 * A support method which checks if a given number appears in a row.
	 * 
	 * @author Alexander Nikolov
	 * @param number The number to check for.
	 * @param r      The row to check at.
	 * @param grid   The grid to check.
	 * @return Returns true if the number already exists somewhere in the row.
	 */
	public boolean appearsInTheRow(int number, int r, Grid grid) {
		boolean result = false;
		for (int k = 1; k < 10; k++) {
			if (grid.getValue(r, k) == number) {
				result = true;
			}
		}

		return result;

	}

	/**
	 * A support method which checks if a given number appears in a column.
	 * 
	 * @author Alexander Nikolov
	 * @param number The number to check for.
	 * @param c      The column to check at.
	 * @param grid   The grid to check.
	 * @return Returns true if the number already exists somewhere in the column.
	 */
	public boolean appearsInTheColumn(int number, int c, Grid grid) {

		boolean result = false;

		for (int k = 1; k < 10; k++) {
			if (grid.getValue(k, c) == number) {
				result = true;
			}
		}
		return result;
	}

}
